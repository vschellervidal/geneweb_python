name: Auto-merge on Approval

on:
  pull_request_review:
    types: [submitted]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  react-to-review:
    runs-on: ubuntu-latest
    steps:
      - name: Handle review and merge/label
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const pr    = context.payload.pull_request;
            const pr_number = pr.number;

            // Helpers
            const STATUS = ['not started','in progress','in review','changes requested','approved'];
            async function setStatus_onPR(pr_number, name) {
              for (const s of STATUS) {
                if (s !== name) {
                  try { await github.rest.issues.removeLabel({ owner, repo, issue_number: pr_number, name: s }); } catch {}
                }
              }
              await github.rest.issues.addLabels({ owner, repo, issue_number: pr_number, labels: [name] });
            }
            async function setStatus_onIssue(issue_number, name) {
              for (const s of STATUS) {
                if (s !== name) {
                  try { await github.rest.issues.removeLabel({ owner, repo, issue_number, name: s }); } catch {}
                }
              }
              await github.rest.issues.addLabels({ owner, repo, issue_number, labels: [name] });
            }

            // État des reviews (on garde la dernière de chaque reviewer)
            const { data: reviews } = await github.rest.pulls.listReviews({ owner, repo, pull_number: pr_number });
            const latestByUser = new Map();
            for (const r of reviews) latestByUser.set(r.user.id, r);
            const decisions = [...latestByUser.values()].map(r => (r.state || '').toLowerCase());

            const hasChangesReq = decisions.includes('changes_requested');
            const hasApprove    = decisions.includes('approved');

            // Récupérer l'issue ID depuis la branche
            const headRef = pr.head.ref || '';
            const match = headRef.match(/^issue-(\d+)(?:-.+)?$/);
            const issue_number = match ? Number(match[1]) : null;

            if (hasChangesReq) {
              await setStatus_onPR(pr_number, 'changes requested');
              if (issue_number) await setStatus_onIssue(issue_number, 'changes requested');

              await github.rest.issues.createComment({
                owner, repo, issue_number: pr_number,
                body: `❗ Des changements ont été demandés. Merci d'adresser les remarques du reviewer.`
              });
              return;
            }

            if (hasApprove) {
              await setStatus_onPR(pr_number, 'approved');
              if (issue_number) await setStatus_onIssue(issue_number, 'approved');

              // Merge (squash)
              await github.rest.pulls.merge({
                owner, repo, pull_number: pr_number,
                merge_method: 'squash'
              });

              // Ferme l'issue si pas déjà fermée (au cas où l’auteur a oublié "Closes #")
              if (issue_number) {
                try {
                  const { data: iss } = await github.rest.issues.get({ owner, repo, issue_number });
                  if (iss.state !== 'closed') {
                    await github.rest.issues.update({ owner, repo, issue_number, state: 'closed' });
                  }
                } catch {}
              }

              // Supprime la branche (si l’option repo ne le fait pas)
              try {
                await github.rest.git.deleteRef({ owner, repo, ref: `heads/${headRef}` });
              } catch (e) {
                if (![422,404].includes(e.status)) throw e;
              }
            }
