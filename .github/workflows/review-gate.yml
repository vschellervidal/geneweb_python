name: Auto-merge on Approval

on:
  pull_request_review:
    types: [submitted]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  react-to-review:
    runs-on: ubuntu-latest
    steps:
      - name: Handle review outcome
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const pr_number = pr.number;

            // Récupère l'état des reviews
            const { data: reviews } = await github.rest.pulls.listReviews({ owner, repo, pull_number: pr_number });

            const latestByUser = new Map();
            for (const r of reviews) latestByUser.set(r.user.id, r);
            const decisions = [...latestByUser.values()].map(r => r.state.toLowerCase());

            const hasChangesReq = decisions.includes('changes_requested');
            const hasApprove    = decisions.includes('approved');

            // Marqueurs d'issue/branche
            const headRef = pr.head.ref || '';
            const match = headRef.match(/^issue-(\d+)(?:-.+)?$/);
            const issue_number = match ? Number(match[1]) : null;

            if (hasChangesReq) {
              // ajoute un label et commente
              try { await github.rest.issues.addLabels({ owner, repo, issue_number: pr_number, labels: ['changes-requested'] }); } catch {}
              await github.rest.issues.createComment({
                owner, repo, issue_number: pr_number,
                body: `❗ Des changements ont été demandés. Merci d'adresser les remarques du reviewer.`
              });
              return;
            }

            if (hasApprove) {
              // Optionnel: label
              try { await github.rest.issues.addLabels({ owner, repo, issue_number: pr_number, labels: ['approved'] }); } catch {}

              // Merge (squash)
              await github.rest.pulls.merge({
                owner, repo, pull_number: pr_number,
                merge_method: 'squash'
              });

              // Ferme l'issue si pas déjà fermée (au cas où "Closes #id" aurait été oublié)
              if (issue_number) {
                try {
                  const { data: iss } = await github.rest.issues.get({ owner, repo, issue_number });
                  if (iss.state !== 'closed') {
                    await github.rest.issues.update({ owner, repo, issue_number, state: 'closed' });
                  }
                } catch {}
              }

              // Supprime la branche (si l’option auto-delete n’est pas activée)
              try {
                await github.rest.git.deleteRef({ owner, repo, ref: `heads/${headRef}` });
              } catch (e) {
                if (![422,404].includes(e.status)) throw e;
              }
            }
